# 目录
* 基础知识
    * 内置类型
    * 关键字
    * 数组
* 面向对象
    * class vs struct
    * 构造和析构
    * 对象创建
    * 派生

# 基础知识
## 内置类型
### 字节数
|类型|字节数|类型|字节数|
|:-|:-:|:-|:-:|
|bool|1|
|char|1|wchar_t|2|
|char16_t|2|char32_t|4|
|float|4|double|8|
|short|2|int|4|
|long|4|long long|8|

### 浮点数
#### 精度计算
估算公式: `2^10 = 1024 ≈ 10^3`，既每10个bit可以表示3位小数<br>
根据IEEE754标准：

|类型|符号位(bits)|阶乘(bits)|小数部分(bits)|精度|
|:-|:-:|:-:|:-:|:-:|
|float|1|8|23|6 - 7位|
|double|1|11|52|15 - 16位|

## 关键字
### sizeof
#### 一、特殊结构
计算时需要注意以下特殊结构：
1. 空类或空结构体，不包含虚函数的字节数为**1**，包含的为**4**；(32位程序是**4**, 64位程序是**8**)
2. 多重派生需要注意，每从一个带虚函数的类派生，大小需要加**4**；(32位程序是**4**, 64位程序是**8**)
3. union是取最大成员的长度。
4. sizeof引用，是对象的大小。

#### 二、字节对齐
1. 结构体中每个成员的位置必须能被其大小整除，否则在成员之间补字节数。
2. 结构体总大小必须是最大成员大小的整数倍，否则在结构体最后补字节数。

**示例**：
```
struct A
{
    int    a;
    // double是8个字节，需要在这里补4个字节
    double b;
    // 不需要补
    char   c;
    // 总大小必须是8的倍数，所以必须补7个字节
};
```

### const
#### 一、修改变量
1. `const type t; type const t;` 含义：t是不可变的；
2. const修饰的变量默认是文件的局部变量；
3. 如果要在其他文件中访问，必须显示指定为它为extern，例如：`extern const int buffsize = 100;`
4. 非const引用只能绑定到与该引用同类型的对象。const引用可以引用不同的类型如：`const int & a = 1.0`。

#### 二、修饰指针
1. const位于*左侧，用来修饰指针指向的变量是不可变的；
2. const位于*右侧，用来修饰指针本身，表示指针不能指向其他变量；

#### 三、修饰类成员
1. 修饰类成员，表示常量成员，只能在初始化列表中初始化；
2. 修饰成员函数，表示常量函数：既不能修改任何成员变量，也不能调用类中任何非const成员函数。

**示例**：
```
int a = 1;
int b = 2;

const int * pa1 = &a;
*pa1 = 11;  // 错误
pa1 = &b;   // 正确

int * const pa2 = &a;
*pa2 = 11;  // 正确
pa2  = &b;  // 错误，不能改变指向
```

### mutable
1. mutable意思是“可变的，易变的“，跟C++中的const是反义词；
2. mutable修饰的变量可以在const函数中被改变。

### static
控制变量的存储方式和可见性。 

#### 一、修饰局部变量
一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束。但是在这里要注意的是，虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。

#### 二、修饰全局变量
对于一个全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问(只需用extern进行声明即可)。用static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。

#### 三、修饰函数
用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域。

#### 四、修饰类中的成员或函数
1. 静态成员变量只能在类外进行单独的初始化，且定义的时候不能带上static；
2. 静态成员函数由于缺乏this指针，所以不能访问非静态成员变量和成员函数。

### 强制类型转换
TODO

## 数组
来源：https://www.cnblogs.com/chenyangyao/p/5222696.html<br>
基础知识：
1. 没有多维数组，多维数组是用一维数组模拟的；
2. 数组名是一个常量（所以不能进行赋值），其代表数组首元素的首地址；
3. 数组与指针的关系是因为数组下标操作符[]，此如，int a[3][2]相当于*(*(a+3)+2)；
4. 指针可以进行加减算术运算，加减的基本单位是sizeof(指针所指向的数据类型)；
5. 对数组的数组名进行取地址(&)操作，其类型为整个数组类型；
6. 对数组的数组名进行sizeof运算符操作，其值为整个数组的大小（以字节为单位）；
7. 数组作为函数形参时会退化为指针。

**示例1**：
```
int a[5];
int * pa1 = a;      // a代表数组元素首元素的地址
int * pa2 = &a[0];  // pa1和pa2等同
int * pa3 = &a;     // 错误：对数组名取地址，表示时指向数组的指针
int (*pa4)[5] = &a; // 正确
a + 1 = &a[0] + 1 = a[1]
```

**示例2**：
```
sizeof(a)  // 表示整个数组的大小
sizeof(&a) // 表示一个指针的大小 
```

# 面向对象
面向对象编程基于三个基本概念：数据抽象、继承、动态绑定。

## class vs struct
1. 默认访问权限不同，class为私有，struct为共有；
2. 默认继承访问权限不同，class默认派生是私有的，struct默认是共有的。

## 构造和析构
### 构造顺序
基类(成员变量 > 构造函数) > 派生类(成员变量 > 构造函数)
1. 成员变量构造和初始化列表构造是一回事，构造的顺序取决于声明的顺序；
2. 先进行成员变量和初始化列表构造，后调用构造函数；
3. 初始化列表的初始化顺序与声明顺序相同；
4. 先构造基类，后构造派生类。
5. 静态成员变量的初始化取决于初始化的位置。

### 析构顺序
1. 先声明后析构；
2. 先类析构，后成员析构；
3. 先析构派生类，后析构基类。

### 虚构造函数
虚函数表指针是在构造函数中进行初始化的，所以如果先使用虚函数表指针进行动态绑定的话，此时指针是无效的，必然引起错误。

### 虚析构函数
静态类型和被删除对象的动态类型有可能不同，此时如果析构函数不是虚函数的话，将导致派生类的析构函数不会被调用，产生问题。

### 构造函数（析构函数）中调用虚函数
如果在构造函数（析构函数）中调用虚函数，则运行的是类自身定义的函数，即不发生动态绑定。（解析：如果在基类的构造函数中发生动态绑定，调用派生类的虚函数，此时，派生类并没有进行构造，引发问题。）

## 对象创建
**要求在堆中创建**
让构造函数成为私有函数。
```c++
// 要求在堆上建立对象
class A
{
private:
    A();
}
```

**禁止在堆中创建**
通常禁止的方法是禁止用户调用new，可以重载operator new函数来达到这个目的。
```c++
// 禁止在堆中建立对象
class B
{
private:
    void * operator new(size_t size);
}
```

## 派生
### 重载、重写、隐藏
#### 重载
1. 相同的范围（在同一个类中）；
2. 函数名称相同；
3. 参数不同。

#### 重写
1. 不同的范围（分别位于派生类于基类）；
2. 函数名字相同；
3. 参数相同；
4. 基类函数必须有virtual关键字。

#### 隐藏
“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
1. 如果派生类的函数与基类的函数同名，但参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏。
2. 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏。