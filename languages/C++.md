# 目录
* 基础知识
    * 内置类型
    * 运算符
    * 关键字
    * 数组
    * 多级指针
* 面向对象
    * class vs struct
    * 构造和析构
    * 对象创建
    * 派生
* 问答
    * delete this合法么？
    * 为什么C++里访问虚函数比访问普通函数慢?

# 基础知识
## 内置类型
### 字节数
|类型|字节数|类型|字节数|
|:-|:-:|:-|:-:|
|bool|1|
|char|1|wchar_t|2|
|char16_t|2|char32_t|4|
|float|4|double|8|
|short|2|int|4|
|long|4|long long|8|

### 浮点数
#### 精度计算
估算公式: `2^10 = 1024 ≈ 10^3`，既每10个bit可以表示3位小数<br>
根据IEEE754标准：

|类型|符号位(bits)|阶乘(bits)|小数部分(bits)|精度|
|:-|:-:|:-:|:-:|:-:|
|float|1|8|23|6 - 7位|
|double|1|11|52|15 - 16位|

## 运算符
### 赋值操作运算符（=）
1. 赋值操作运算符（=）的结合性是从右向左的；
2. 重载时需要考虑自己赋值给自己的情况。

## 关键字
### sizeof
#### 一、特殊结构
计算时需要注意以下特殊结构：
1. 空类或空结构体，不包含虚函数的字节数为**1**，包含的为**4**；(32位程序是**4**, 64位程序是**8**)
2. 多重派生需要注意，每从一个带虚函数的类派生，大小需要加**4**；(32位程序是**4**, 64位程序是**8**)
3. union是取最大成员的长度。
4. sizeof引用，是对象的大小。

#### 二、字节对齐
1. 结构体中每个成员的位置必须能被其大小整除，否则在成员之间补字节数。
2. 结构体总大小必须是最大成员大小的整数倍，否则在结构体最后补字节数。

**示例**：
``` C++
struct A
{
    int    a;
    // double是8个字节，需要在这里补4个字节
    double b;
    // 不需要补
    char   c;
    // 总大小必须是8的倍数，所以必须补7个字节
};
```

### const
#### 一、修改变量
1. `const type t; type const t;` 含义：t是不可变的；
2. const修饰的变量默认是文件的局部变量；
3. 如果要在其他文件中访问，必须显示指定为它为extern，例如：`extern const int buffsize = 100;`
4. 非const引用只能绑定到与该引用同类型的对象。const引用可以引用不同的类型如：`const int & a = 1.0`。

#### 二、修饰指针
1. const位于*左侧，用来修饰指针指向的变量是不可变的；
2. const位于*右侧，用来修饰指针本身，表示指针不能指向其他变量；

#### 三、修饰类成员
1. 修饰类成员，表示常量成员，只能在初始化列表中初始化；
2. 修饰成员函数，表示常量函数：既不能修改任何成员变量，也不能调用类中任何非const成员函数。

**示例**：
``` C++
int a = 1;
int b = 2;

const int * pa1 = &a;
*pa1 = 11;  // 错误
pa1 = &b;   // 正确

int * const pa2 = &a;
*pa2 = 11;  // 正确
pa2  = &b;  // 错误，不能改变指向
```

### mutable
1. mutable意思是“可变的，易变的“，跟C++中的const是反义词；
2. mutable修饰的变量可以在const函数中被改变。

### static
控制变量的存储方式和可见性。 

#### 一、修饰局部变量
一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束。但是在这里要注意的是，虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。

#### 二、修饰全局变量
对于一个全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问(只需用extern进行声明即可)。用static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。

#### 三、修饰函数
用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域。

#### 四、修饰类中的成员或函数
1. 静态成员变量只能在类外进行单独的初始化，且定义的时候不能带上static；
2. 静态成员函数由于缺乏this指针，所以不能访问非静态成员变量和成员函数。

### 强制类型转换
#### 一、dynamic_cast
唯一一个运行时进行的类型转换。其特性如下：
1. 不能用于内置的基本数据类型的强制转换，且仅能用于指针或者引用；
2. 转换如果成功的话返回的是指向类的指针或引用，如果转换失败的话则会返回NULL；
3. 基类中一定要有虚函数，否则编译不通过；（由于运行时类型检查需要的运行时类型信息，而这个信息存储在类的虚函数表中。只有定义了虚函数的类才有虚函数表）
4. 区别于static_cast，不能进行基类到派生类之间的转换；(不会发生编译错误，只是返回的额指针为null)
5. dynamic_cast不是一个常量时间操作，会有性能损失。

#### 二、static_cast
1. 可以实现基本数据类型之间的转换；（类型之间需要有关联，比如不能将数值转换为指针）
2. 如果涉及到类的话，必须存在派生关系才能进行转换；（可以由基类转换到派生类，这种转换是不安全的）

#### 三、explicit
1. 修饰单参数的构造函数，被修饰的类不能发生隐式类型转换；
2. explicit关键字只能用于声明上，定义不需要。

### inline
#### 一、使用
1. 相当于把内联函数里面的内容写在调用内联函数处；
2. 相当于不用执行进入函数的步骤，直接执行函数体；
3. 相当于宏，却比宏多了类型检查，真正具有函数特性；
4. 不能包含循环、递归、switch 等复杂操作；
5. 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

**备注**：inline可以用来消除定义在头文件的函数的重复定义的问题。

#### 二、优缺点
**优点**
1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度；
2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会；
3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能；
4. 内联函数在运行时可调试，而宏定义不可以。

**缺点**
1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间；
2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接；
3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

#### 四、虚函数可以是内联函数吗？
1. 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联；
2. 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联；
3. inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类，这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

## 数组
来源：https://www.cnblogs.com/chenyangyao/p/5222696.html<br>
基础知识：
1. 没有多维数组，多维数组是用一维数组模拟的；
2. 数组名是一个常量（所以不能进行赋值），其代表数组首元素的首地址；
3. 数组与指针的关系是因为数组下标操作符[]，此如，int a[3][2]相当于*(*(a+3)+2)；
4. 指针可以进行加减算术运算，加减的基本单位是sizeof(指针所指向的数据类型)；
5. 对数组的数组名进行取地址(&)操作，其类型为整个数组类型；
6. 对数组的数组名进行sizeof运算符操作，其值为整个数组的大小（以字节为单位）；
7. 数组作为函数形参时会退化为指针。

**示例1**：
``` C++
int a[5];
int * pa1 = a;      // a代表数组元素首元素的地址
int * pa2 = &a[0];  // pa1和pa2等同
int * pa3 = &a;     // 错误：对数组名取地址，表示时指向数组的指针
int (*pa4)[5] = &a; // 正确
a + 1 = &a[0] + 1 = a[1]
```

**示例2**：
``` C++
sizeof(a)  // 表示整个数组的大小
sizeof(&a) // 表示一个指针的大小 
```

## 多级指针
来源：https://www.cnblogs.com/chenyangyao/p/5222696.html<br>

**示例**
``` C++
char *p     = "hello world";
char **pp   = &p;            // 二级指针
char ***ppp = &pp;           // 三级指针
```

# 面向对象
面向对象编程基于三个基本概念：数据抽象、继承、动态绑定。

## class vs struct
1. 默认访问权限不同，class为私有，struct为共有；
2. 默认继承访问权限不同，class默认派生是私有的，struct默认是共有的。

## 构造和析构
### 构造顺序
基类(成员变量 > 构造函数) > 派生类(成员变量 > 构造函数)
1. 成员变量构造和初始化列表构造是一回事，构造的顺序取决于声明的顺序；
2. 先进行成员变量和初始化列表构造，后调用构造函数；
3. 初始化列表的初始化顺序与声明顺序相同；
4. 先构造基类，后构造派生类。
5. 静态成员变量的初始化取决于初始化的位置。
6. 多重派生的基类构造顺序，与派生声明的顺序相同。

### 析构顺序
1. 先声明后析构；
2. 先类析构，后成员析构；
3. 先析构派生类，后析构基类。

### 虚构造函数
虚函数表指针是在构造函数中进行初始化的，所以如果先使用虚函数表指针进行动态绑定的话，此时指针是无效的，必然引起错误。

### 虚析构函数
静态类型和被删除对象的动态类型有可能不同，此时如果析构函数不是虚函数的话，将导致派生类的析构函数不会被调用，产生问题。

### 构造函数（析构函数）中调用虚函数
如果在构造函数（析构函数）中调用虚函数，则运行的是类自身定义的函数，即不发生动态绑定。（解析：如果在基类的构造函数中发生动态绑定，调用派生类的虚函数，此时，派生类并没有进行构造，引发问题。）

### 基类函数不是虚函数，而派生类是虚函数，此时是否发生动态绑定？
不发生，因为基类没有虚函数表，无法发生动态绑定。
``` C++
class Person
{
public:

    void print()
    {
        qInfo()<<"Person::print";
    }
};
class Student: public Person
{
public:

    virtual void print()
    {
        qInfo()<<"Student::print";
    }
};

Person * p = new Student;
p->print(); // Person::print 不发生动态绑定

```

## 对象创建
**要求在堆中创建**
让构造函数成为私有函数。
```c++
// 要求在堆上建立对象
class A
{
private:
    A();
}
```

**禁止在堆中创建**
通常禁止的方法是禁止用户调用new，可以重载operator new函数来达到这个目的。
```c++
// 禁止在堆中建立对象
class B
{
private:
    void * operator new(size_t size);
}
```

## 派生
### 重载、重写、隐藏
#### 重载
1. 相同的范围（在同一个类中）；
2. 函数名称相同；
3. 参数不同。

#### 重写
1. 不同的范围（分别位于派生类于基类）；
2. 函数名字相同；
3. 参数相同；
4. 基类函数必须有virtual关键字。

#### 隐藏
“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
1. 如果派生类的函数与基类的函数同名，但参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏。
2. 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏。

### 虚函数表
来源：http://blog.csdn.net/haoel/article/details/1948051/

虚函数的原理就是利用**虚指针**（占用类对象的存储空间）和**虚表**（不占用类对象的存储空间， 虚表和对象无关）来实现的。

### 虚继承
原理：https://blog.csdn.net/longlovefilm/article/details/80558879

#### 为什么需要虚继承？
虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。

#### 虚继承的虚函数
和普通继承的虚函数一样的多态性。<br>
**问**：虚继承的类如果包含虚函数的话，会再创建一个虚函数指针，为什么会这样呢？<br>
**答**：因为现有虚函数的逻辑是取虚函数表指针，然后访问其中的函数，而在虚继承中，如果需要使用基类的虚函数表指针的话，需要先通过虚基类的指针访问到基类，再访问其中的虚函数表指针，增加实现的复杂度，同时效率也大大降低。

**问**：既然虚继承使用继承类的虚函数表指针，那为什么复制基类结构的时候，要复制基类的虚函数表指针呢？<br>
**答**：很显然的，同一种结构体应该只有一种结构大小，如果不复制虚函数表指针的话，就会出现一种结构体2种大小，对于访问和使用是要命的。

#### 虚继承的字节计算
说明：包含虚继承，会多出一个vbptr指向虚基类的偏移，所以要加4(32位程序，64位加8)，另外需要注意的是虚函数表的指针。<br>

**示例**：
``` C++
// 情况1: 这种情况下B是4个字节(A的虚函数指针)
class A
{
public:
	A() { cout << "A::A();" << endl; }

	virtual void add()
	{
		cout << "A::add()" << endl;
	}
};
class B : public A
{
public:
	B() { cout << "B::B();" << endl; }

    void add()
	{
		cout << "B::add()" << endl;
	}
};

// 情况2: 这种情况下B是12个字节(A的虚函数指针 + 虚基类指针 + B的虚函数指针)
class A
{
public:
	A() { cout << "A::A();" << endl; }

	virtual void add()
	{
		cout << "A::add()" << endl;
	}
};
class B : public virtual A
{
public:
	B() { cout << "B::B();" << endl; }

    void add() // !!!!注意：这里虽然没有加virtual，但也是虚函数
	{
		cout << "B::add()" << endl;
	}
};

// 情况3: 这种情况下B是4个字节(虚基类指针)
class A
{
public:
	A() { cout << "A::A();" << endl; }

	void add()
	{
		cout << "A::add()" << endl;
	}
};
class B : public virtual A
{
public:
	B() { cout << "B::B();" << endl; }

    void add()
	{
		cout << "B::add()" << endl;
	}
};

// 情况4: 这种情况下B是8个字节(B的虚函数指针 + 虚基类指针)
class A
{
public:
	A() { cout << "A::A();" << endl; }

	void add()
	{
		cout << "A::add()" << endl;
	}
};
class B : public virtual A
{
public:
	B() { cout << "B::B();" << endl; }

    virtual void add()
	{
		cout << "B::add()" << endl;
	}
};
```

## 问答
### delete this合法么？
合法，但：
1. 必须保证 this 对象是通过 new（不是 new[]、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的；
2. 必须保证调用 delete this 的成员函数是最后一个调用 this 的成员函数；
3. 必须保证成员函数的 delete this 后面没有调用 this 了；
4. 必须保证 delete this 后没有人使用了。

### 为什么 C++里访问虚函数比访问普通函数慢?
TODO

### 内存分配方式有三种
TODO